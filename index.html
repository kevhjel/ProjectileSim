<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Projectile Motion + Goal + Multi-ball Interference (Inches)</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.08);
      --panel2: rgba(255,255,255,0.05);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --border: rgba(255,255,255,0.12);
      --accent: #7dd3fc;
      --accent2: #a78bfa;
      --warn: #fbbf24;
      --ok: #34d399;
      --bad: #fb7185;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1000px 600px at 20% 10%, rgba(125,211,252,0.16), transparent 55%),
                  radial-gradient(900px 600px at 80% 20%, rgba(167,139,250,0.12), transparent 60%),
                  var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .app {
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 16px;
      padding: 16px;
      box-sizing: border-box;
      height: 100%;
    }

    @media (max-width: 980px) {
      .app {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      backdrop-filter: blur(10px);
    }

    .panel h1 {
      margin: 0 0 10px 0;
      font-size: 16px;
      letter-spacing: 0.3px;
    }

    .sub {
      color: var(--muted);
      font-size: 12px;
      margin: 0 0 14px 0;
      line-height: 1.35;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      margin-bottom: 10px;
    }

    .labelRow {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }

    label {
      font-size: 12px;
      color: var(--muted);
    }

    .units {
      opacity: 0.75;
      font-size: 11px;
      margin-left: 6px;
    }

    .valueWrap {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    input[type="range"] {
      width: 100%;
    }

    input[type="number"] {
      width: 120px;
      box-sizing: border-box;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 7px 8px;
      color: var(--text);
      outline: none;
      font-variant-numeric: tabular-nums;
    }

    input[type="checkbox"] { transform: translateY(1px); }

    .buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .buttons3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    button {
      background: linear-gradient(180deg, rgba(125,211,252,0.22), rgba(125,211,252,0.12));
      border: 1px solid rgba(125,211,252,0.35);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.06s ease, filter 0.15s ease;
    }

    button.secondary {
      background: linear-gradient(180deg, rgba(167,139,250,0.20), rgba(167,139,250,0.10));
      border: 1px solid rgba(167,139,250,0.35);
    }

    button.danger {
      background: linear-gradient(180deg, rgba(251,113,133,0.22), rgba(251,113,133,0.10));
      border: 1px solid rgba(251,113,133,0.35);
    }

    button:active { transform: translateY(1px); }
    button:hover { filter: brightness(1.05); }

    .stats {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      line-height: 1.55;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      margin-left: 6px;
      font-variant-numeric: tabular-nums;
    }

    .pill.ok { border-color: rgba(52,211,153,0.45); background: rgba(52,211,153,0.12); color: rgba(209,250,229,0.95); }
    .pill.bad { border-color: rgba(251,113,133,0.45); background: rgba(251,113,133,0.10); color: rgba(255,228,230,0.95); }
    .pill.warn{ border-color: rgba(251,191,36,0.45); background: rgba(251,191,36,0.10); color: rgba(255,251,235,0.95); }

    .canvasWrap {
      position: relative;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 16px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    }

    .hud {
      position: absolute;
      left: 14px;
      top: 14px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      line-height: 1.4;
      max-width: 380px;
    }

    .hud strong { color: rgba(255,255,255,0.95); }

    .tiny {
      font-size: 11px;
      color: rgba(255,255,255,0.70);
      margin-top: 6px;
    }

    .kbd {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.07);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      margin: 0 2px;
    }

    .settingsBox {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    textarea {
      width: 100%;
      min-height: 92px;
      resize: vertical;
      background: rgba(0,0,0,0.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text);
      padding: 10px;
      box-sizing: border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      line-height: 1.35;
      outline: none;
    }

    .fileRow {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 8px;
    }

    .fileRow input[type="file"]{
      width: 100%;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Projectile Motion Simulator <span class="pill">Units: inches</span></h1>
      <p class="sub">
        Side-view 2D ballistic model (no drag). Goal is a top-opening “bucket” at a given distance.
        Set a firing rate to visualize multiple balls in flight along the same path.
      </p>

      <!-- Launch -->
      <div class="grid">
        <div class="row">
          <div class="labelRow">
            <label>Start height y₀ <span class="units">(in)</span></label>
            <div class="valueWrap">
              <input id="y0_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="y0" type="range" min="0" max="240" step="0.1" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Angle θ <span class="units">(deg)</span></label>
            <div class="valueWrap">
              <input id="ang_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="ang" type="range" min="0" max="85" step="0.1" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Speed v₀ <span class="units">(in/s)</span></label>
            <div class="valueWrap">
              <input id="v0_num" type="number" step="1" />
            </div>
          </div>
          <input id="v0" type="range" min="0" max="1200" step="1" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Gravity g <span class="units">(in/s²)</span></label>
            <div class="valueWrap">
              <input id="g_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="g" type="range" min="0" max="800" step="0.1" />
        </div>
      </div>

      <!-- Goal -->
      <div class="grid">
        <div class="row">
          <div class="labelRow">
            <label>Goal distance xg <span class="units">(in)</span></label>
            <div class="valueWrap">
              <input id="xg_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="xg" type="range" min="1" max="1200" step="0.1" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Goal rim height yg <span class="units">(in)</span></label>
            <div class="valueWrap">
              <input id="yg_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="yg" type="range" min="0" max="600" step="0.1" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Goal opening width wg <span class="units">(in)</span></label>
            <div class="valueWrap">
              <input id="wg_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="wg" type="range" min="0.5" max="240" step="0.1" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Goal depth (visual) <span class="units">(in)</span></label>
            <div class="valueWrap">
              <input id="depth_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="depth" type="range" min="0.5" max="240" step="0.1" />
        </div>
      </div>

      <!-- Balls / timing -->
      <div class="grid">
        <div class="row">
          <div class="labelRow">
            <label>Fire rate <span class="units">(balls/sec)</span></label>
            <div class="valueWrap">
              <input id="rate_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="rate" type="range" min="0" max="20" step="0.01" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Ball radius <span class="units">(in)</span></label>
            <div class="valueWrap">
              <input id="r_num" type="number" step="0.1" />
            </div>
          </div>
          <input id="r" type="range" min="0.1" max="24" step="0.1" />
        </div>
      </div>

      <div class="grid">
        <div class="row">
          <div class="labelRow">
            <label>Playback speed</label>
            <div class="valueWrap">
              <input id="speed_num" type="number" step="0.01" />
            </div>
          </div>
          <input id="speed" type="range" min="0.1" max="4" step="0.01" />
        </div>

        <div class="row">
          <div class="labelRow">
            <label>Max balls on screen</label>
            <div class="valueWrap">
              <input id="maxBalls_num" type="number" step="1" />
            </div>
          </div>
          <input id="maxBalls" type="range" min="1" max="250" step="1" />
        </div>
      </div>

      <div class="grid">
        <div class="row">
          <label>
            <span>Show trajectory curve</span>
            <span class="valueWrap"><input id="showCurve" type="checkbox" /></span>
          </label>
          <label>
            <span>Show time ticks</span>
            <span class="valueWrap"><input id="showTicks" type="checkbox" /></span>
          </label>
        </div>
        <div class="row">
          <label>
            <span>Follow camera (auto-zoom)</span>
            <span class="valueWrap"><input id="autoZoom" type="checkbox" /></span>
          </label>
          <label>
            <span>Pause</span>
            <span class="valueWrap"><input id="paused" type="checkbox" /></span>
          </label>
        </div>
      </div>

      <div class="buttons">
        <button id="reset">Reset time</button>
        <button class="secondary" id="saveLocal">Save (local)</button>
      </div>

      <div class="settingsBox">
        <div class="buttons3">
          <button id="exportBtn">Export .json</button>
          <button class="secondary" id="copyBtn">Copy text</button>
          <button class="secondary" id="applyTextBtn">Apply text</button>
        </div>
        <div class="fileRow">
          <input id="importFile" type="file" accept=".json,application/json" />
          <button class="secondary" id="importBtn">Import file</button>
        </div>
        <textarea id="settingsText" spellcheck="false" placeholder="Settings JSON will appear here when you copy/export. You can also paste JSON here and click Apply text."></textarea>
      </div>

      <div class="stats" id="stats"></div>
    </div>

    <div class="canvasWrap panel">
      <canvas id="c"></canvas>
      <div class="hud" id="hud">
        <div><strong>Controls:</strong> <span class="kbd">Space</span> pause/resume • <span class="kbd">R</span> reset time</div>
        <div class="tiny">
          “Score” = ball center crosses down through the rim line within the opening width. No rim collision modeling yet.
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================
    // Units
    // ============================
    const IN_TO_M = 0.0254;
    const M_TO_IN = 1 / IN_TO_M;

    function inToM(xIn) { return xIn * IN_TO_M; }
    function mToIn(xM) { return xM * M_TO_IN; }

    // velocity: in/s -> m/s, acceleration: in/s^2 -> m/s^2 uses same scale
    function inPerSecToMPerSec(vIn) { return vIn * IN_TO_M; }
    function mPerSecToInPerSec(vM) { return vM * M_TO_IN; }

    function inPerSec2ToMPerSec2(aIn) { return aIn * IN_TO_M; }
    function mPerSec2ToInPerSec2(aM) { return aM * M_TO_IN; }

    // ============================
    // Utilities
    // ============================
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const deg2rad = (d) => d * Math.PI / 180;

    function fmt(x, digits=2) {
      if (!isFinite(x)) return "—";
      return x.toFixed(digits);
    }

    // ============================
    // DOM
    // ============================
    const el = (id) => document.getElementById(id);

    const controls = {
      // range inputs
      y0: el("y0"),
      ang: el("ang"),
      v0: el("v0"),
      g: el("g"),
      xg: el("xg"),
      yg: el("yg"),
      wg: el("wg"),
      depth: el("depth"),
      rate: el("rate"),
      r: el("r"),
      speed: el("speed"),
      maxBalls: el("maxBalls"),

      // number inputs
      y0_num: el("y0_num"),
      ang_num: el("ang_num"),
      v0_num: el("v0_num"),
      g_num: el("g_num"),
      xg_num: el("xg_num"),
      yg_num: el("yg_num"),
      wg_num: el("wg_num"),
      depth_num: el("depth_num"),
      rate_num: el("rate_num"),
      r_num: el("r_num"),
      speed_num: el("speed_num"),
      maxBalls_num: el("maxBalls_num"),

      // toggles
      showCurve: el("showCurve"),
      showTicks: el("showTicks"),
      autoZoom: el("autoZoom"),
      paused: el("paused"),

      // actions
      reset: el("reset"),
      saveLocal: el("saveLocal"),

      exportBtn: el("exportBtn"),
      copyBtn: el("copyBtn"),
      applyTextBtn: el("applyTextBtn"),
      importFile: el("importFile"),
      importBtn: el("importBtn"),

      settingsText: el("settingsText"),
      stats: el("stats"),
    };

    // ============================
    // Defaults (UI units: inches, in/s, in/s^2)
    // ============================
    const DEFAULTS = {
      y0: 40.0,          // in
      ang: 45.0,         // deg
      v0: 400.0,         // in/s
      g: 386.09,         // in/s^2 (Earth)
      xg: 120.0,         // in
      yg: 100.0,         // in
      wg: 24.0,          // in
      depth: 18.0,       // in (visual)
      rate: 5.0,         // balls/s
      r: 3.5,            // in
      speed: 1.0,        // sim playback multiplier
      maxBalls: 120,
      showCurve: true,
      showTicks: true,
      autoZoom: true,
      paused: false
    };

    // Schema version so exported files are future-proof-ish
    const SETTINGS_VERSION = 1;

    // ============================
    // Read/write UI
    // ============================
    function readUI() {
      return {
        y0: parseFloat(controls.y0.value),
        ang: parseFloat(controls.ang.value),
        v0: parseFloat(controls.v0.value),
        g: parseFloat(controls.g.value),
        xg: parseFloat(controls.xg.value),
        yg: parseFloat(controls.yg.value),
        wg: parseFloat(controls.wg.value),
        depth: parseFloat(controls.depth.value),
        rate: parseFloat(controls.rate.value),
        r: parseFloat(controls.r.value),
        speed: parseFloat(controls.speed.value),
        maxBalls: parseInt(controls.maxBalls.value, 10),
        showCurve: controls.showCurve.checked,
        showTicks: controls.showTicks.checked,
        autoZoom: controls.autoZoom.checked,
        paused: controls.paused.checked
      };
    }

    function writeUI(p) {
      // ranges
      controls.y0.value = p.y0;
      controls.ang.value = p.ang;
      controls.v0.value = p.v0;
      controls.g.value = p.g;
      controls.xg.value = p.xg;
      controls.yg.value = p.yg;
      controls.wg.value = p.wg;
      controls.depth.value = p.depth;
      controls.rate.value = p.rate;
      controls.r.value = p.r;
      controls.speed.value = p.speed;
      controls.maxBalls.value = p.maxBalls;

      // checkboxes
      controls.showCurve.checked = !!p.showCurve;
      controls.showTicks.checked = !!p.showTicks;
      controls.autoZoom.checked = !!p.autoZoom;
      controls.paused.checked = !!p.paused;

      // number boxes mirror
      syncNumbersFromRanges();
    }

    function syncNumbersFromRanges() {
      controls.y0_num.value = controls.y0.value;
      controls.ang_num.value = controls.ang.value;
      controls.v0_num.value = controls.v0.value;
      controls.g_num.value  = controls.g.value;
      controls.xg_num.value = controls.xg.value;
      controls.yg_num.value = controls.yg.value;
      controls.wg_num.value = controls.wg.value;
      controls.depth_num.value = controls.depth.value;
      controls.rate_num.value = controls.rate.value;
      controls.r_num.value = controls.r.value;
      controls.speed_num.value = controls.speed.value;
      controls.maxBalls_num.value = controls.maxBalls.value;
    }

    function setRangeFromNumber(rangeEl, numberEl) {
      let v = parseFloat(numberEl.value);
      if (!isFinite(v)) return;

      const min = parseFloat(rangeEl.min);
      const max = parseFloat(rangeEl.max);
      v = clamp(v, min, max);

      // snap to step if step exists
      const step = parseFloat(rangeEl.step);
      if (isFinite(step) && step > 0) {
        v = Math.round(v / step) * step;
        v = clamp(v, min, max);
      }

      rangeEl.value = String(v);
      numberEl.value = String(v);
    }

    // ============================
    // Local storage save/load
    // ============================
    function loadSettingsLocal() {
      try {
        const raw = localStorage.getItem("projSimInchSettingsV1");
        if (!raw) return { ...DEFAULTS };
        const parsed = JSON.parse(raw);
        return sanitizeSettings({ ...DEFAULTS, ...parsed });
      } catch {
        return { ...DEFAULTS };
      }
    }

    function saveSettingsLocal() {
      const p = readUI();
      localStorage.setItem("projSimInchSettingsV1", JSON.stringify(p));
    }

    // ============================
    // Export / Import
    // ============================
    function currentSettingsEnvelope() {
      return {
        version: SETTINGS_VERSION,
        units: "in, in/s, in/s^2",
        createdAt: new Date().toISOString(),
        settings: readUI()
      };
    }

    function sanitizeSettings(obj) {
      // accept either envelope or raw settings
      const s = obj && obj.settings ? obj.settings : obj;

      const out = { ...DEFAULTS, ...(s || {}) };

      // clamp to UI ranges
      out.y0 = clamp(out.y0, parseFloat(controls.y0.min), parseFloat(controls.y0.max));
      out.ang = clamp(out.ang, parseFloat(controls.ang.min), parseFloat(controls.ang.max));
      out.v0 = clamp(out.v0, parseFloat(controls.v0.min), parseFloat(controls.v0.max));
      out.g  = clamp(out.g,  parseFloat(controls.g.min),  parseFloat(controls.g.max));
      out.xg = clamp(out.xg, parseFloat(controls.xg.min), parseFloat(controls.xg.max));
      out.yg = clamp(out.yg, parseFloat(controls.yg.min), parseFloat(controls.yg.max));
      out.wg = clamp(out.wg, parseFloat(controls.wg.min), parseFloat(controls.wg.max));
      out.depth = clamp(out.depth, parseFloat(controls.depth.min), parseFloat(controls.depth.max));
      out.rate = clamp(out.rate, parseFloat(controls.rate.min), parseFloat(controls.rate.max));
      out.r = clamp(out.r, parseFloat(controls.r.min), parseFloat(controls.r.max));
      out.speed = clamp(out.speed, parseFloat(controls.speed.min), parseFloat(controls.speed.max));
      out.maxBalls = clamp(parseInt(out.maxBalls, 10) || DEFAULTS.maxBalls,
                           parseInt(controls.maxBalls.min, 10),
                           parseInt(controls.maxBalls.max, 10));

      out.showCurve = !!out.showCurve;
      out.showTicks = !!out.showTicks;
      out.autoZoom = !!out.autoZoom;
      out.paused = !!out.paused;

      return out;
    }

    function exportToFile() {
      const env = currentSettingsEnvelope();
      const text = JSON.stringify(env, null, 2);
      controls.settingsText.value = text;

      const blob = new Blob([text], { type: "application/json" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;

      const safeTs = new Date().toISOString().replace(/[:.]/g, "-");
      a.download = `projectile_settings_${safeTs}.json`;

      document.body.appendChild(a);
      a.click();
      a.remove();

      URL.revokeObjectURL(url);
    }

    async function importFromFile(file) {
      const text = await file.text();
      controls.settingsText.value = text;
      applySettingsText(text);
    }

    function applySettingsText(text) {
      try {
        const parsed = JSON.parse(text);
        const s = sanitizeSettings(parsed);
        writeUI(s);

        recomputeDerived();
        updateStats();
        resetTime();
      } catch (e) {
        alert("Could not parse settings JSON. Make sure it's valid JSON.");
      }
    }

    async function copySettingsText() {
      const env = currentSettingsEnvelope();
      const text = JSON.stringify(env, null, 2);
      controls.settingsText.value = text;
      try {
        await navigator.clipboard.writeText(text);
      } catch {
        // clipboard might fail; at least it's in the textbox
      }
    }

    // ============================
    // Physics (internally in meters)
    // ============================
    function uiToSim(pUI) {
      return {
        y0_m: inToM(pUI.y0),
        ang_deg: pUI.ang,
        v0_mps: inPerSecToMPerSec(pUI.v0),
        g_mps2: inPerSec2ToMPerSec2(pUI.g),
        xg_m: inToM(pUI.xg),
        yg_m: inToM(pUI.yg),
        wg_m: inToM(pUI.wg),
        depth_m: inToM(pUI.depth),
        r_m: inToM(pUI.r),
        rate: pUI.rate,
        speed: pUI.speed,
        maxBalls: pUI.maxBalls,
        showCurve: pUI.showCurve,
        showTicks: pUI.showTicks,
        autoZoom: pUI.autoZoom,
        paused: pUI.paused
      };
    }

    function stateAtTime(sim, t) {
      const th = deg2rad(sim.ang_deg);
      const vx = sim.v0_mps * Math.cos(th);
      const vy = sim.v0_mps * Math.sin(th);

      const x = vx * t;
      const y = sim.y0_m + vy * t - 0.5 * sim.g_mps2 * t * t;

      return { x, y, vx, vy: (vy - sim.g_mps2 * t) };
    }

    function timeOfFlightToGround(sim) {
      const th = deg2rad(sim.ang_deg);
      const vy0 = sim.v0_mps * Math.sin(th);
      const a = -0.5 * sim.g_mps2;
      const b = vy0;
      const c = sim.y0_m;

      if (Math.abs(sim.g_mps2) < 1e-9) {
        if (Math.abs(b) < 1e-9) return Infinity;
        const t = -c / b;
        return t > 0 ? t : Infinity;
      }

      const disc = b*b - 4*a*c;
      if (disc < 0) return Infinity;

      const s = Math.sqrt(disc);
      const t1 = (-b + s) / (2*a);
      const t2 = (-b - s) / (2*a);
      const tPos = [t1, t2].filter(t => t > 1e-9).sort((m,n)=>m-n);
      return tPos.length ? tPos[0] : Infinity;
    }

    function timeToReachX(sim, x) {
      const th = deg2rad(sim.ang_deg);
      const vx = sim.v0_mps * Math.cos(th);
      if (Math.abs(vx) < 1e-9) return Infinity;
      const t = x / vx;
      return t >= 0 ? t : Infinity;
    }

    function scores(sim) {
      const th = deg2rad(sim.ang_deg);
      const vx = sim.v0_mps * Math.cos(th);
      const vy0 = sim.v0_mps * Math.sin(th);

      if (Math.abs(vx) < 1e-9) return { score: false, reason: "No forward x velocity" };

      const xLeft = sim.xg_m - sim.wg_m/2;
      const xRight = sim.xg_m + sim.wg_m/2;

      const tL = timeToReachX(sim, xLeft);
      const tR = timeToReachX(sim, xRight);
      if (!isFinite(tL) || !isFinite(tR)) return { score: false, reason: "No opening interval" };

      const tIn0 = Math.min(tL, tR);
      const tIn1 = Math.max(tL, tR);

      // Solve y(t)=yg
      const a = -0.5 * sim.g_mps2;
      const b = vy0;
      const c = sim.y0_m - sim.yg_m;

      if (Math.abs(sim.g_mps2) < 1e-9) {
        if (Math.abs(vy0) < 1e-9) return { score: false, reason: "No vertical motion" };
        const tCross = (sim.yg_m - sim.y0_m) / vy0;
        if (tCross >= tIn0 && tCross <= tIn1 && vy0 < 0) return { score: true, t: tCross };
        return { score: false, reason: "No downward rim crossing in opening" };
      }

      const disc = b*b - 4*a*c;
      if (disc < 0) return { score: false, reason: "Never reaches rim height" };

      const s = Math.sqrt(disc);
      const tA = (-b + s) / (2*a);
      const tB = (-b - s) / (2*a);

      const candidates = [tA, tB].filter(t => isFinite(t) && t >= 0);
      const valid = candidates.filter(t => (t >= tIn0 && t <= tIn1) && (vy0 - sim.g_mps2 * t < 0));

      if (!valid.length) return { score: false, reason: "No downward rim crossing in opening" };
      const tCross = valid.sort((m,n)=>m-n)[0];
      return { score: true, t: tCross };
    }

    // ============================
    // Rendering
    // ============================
    const canvas = el("c");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resizeCanvas);

    function chooseNiceStep(targetWorldStep) {
      const pow = Math.pow(10, Math.floor(Math.log10(targetWorldStep)));
      const candidates = [1, 2, 5, 10].map(k => k * pow);
      let best = candidates[0];
      let bestErr = Math.abs(best - targetWorldStep);
      for (const c of candidates) {
        const err = Math.abs(c - targetWorldStep);
        if (err < bestErr) { best = c; bestErr = err; }
      }
      return best;
    }

    function makeView(sim) {
      // Auto-view bounds based on trajectory + goal (in meters)
      const th = deg2rad(sim.ang_deg);
      const vx = sim.v0_mps * Math.cos(th);
      const vy = sim.v0_mps * Math.sin(th);

      const tGround = timeOfFlightToGround(sim);
      const tMax = isFinite(tGround) ? tGround : 6;

      let xMax = 0, yMax = sim.y0_m;
      const samples = 220;
      for (let i = 0; i <= samples; i++) {
        const tt = (tMax * i) / samples;
        const s = stateAtTime(sim, tt);
        if (s.x > xMax) xMax = s.x;
        if (s.y > yMax) yMax = s.y;
      }

      xMax = Math.max(xMax, sim.xg_m + sim.wg_m/2 + inToM(24));
      yMax = Math.max(yMax, sim.yg_m + inToM(24));

      const xMin = -inToM(24);
      const yMin = -inToM(12);

      const padX = inToM(24);
      const padY = inToM(24);

      const wx0 = xMin - padX;
      const wx1 = xMax + padX;
      const wy0 = yMin - padY;
      const wy1 = yMax + padY;

      const w = canvas.clientWidth;
      const h = canvas.clientHeight;

      const sx = w / (wx1 - wx0);
      const sy = h / (wy1 - wy0);
      const smin = Math.min(sx, sy);

      const viewW = w / smin;
      const viewH = h / smin;

      const cx = (wx0 + wx1) / 2;
      const cy = (wy0 + wy1) / 2;

      const vx0 = cx - viewW/2;
      const vy0 = cy - viewH/2;

      return {
        scale: smin,
        worldX0: vx0,
        worldY0: vy0,
        viewW,
        viewH,
        toScreen(x, y) {
          const px = (x - vx0) * smin;
          const py = h - (y - vy0) * smin;
          return { px, py };
        },
        metersToPixels(m) { return m * smin; }
      };
    }

    function clear() {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
    }

    function drawGrid(view) {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;

      ctx.save();
      ctx.globalAlpha = 0.35;

      // target ~90px grid spacing; convert pixels->world meters
      const step = chooseNiceStep((1 / view.scale) * 90);
      const minor = step / 5;

      drawGridLines(view, minor, 0.08);
      drawGridLines(view, step, 0.14);

      ctx.restore();

      // ground line y=0
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.lineWidth = 2;
      const a = view.toScreen(view.worldX0, 0);
      const b = view.toScreen(view.worldX0 + view.viewW, 0);
      ctx.beginPath();
      ctx.moveTo(a.px, a.py);
      ctx.lineTo(b.px, b.py);
      ctx.stroke();
      ctx.restore();
    }

    function drawGridLines(view, step, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.lineWidth = 1;

      const x0 = Math.floor(view.worldX0 / step) * step;
      const x1 = view.worldX0 + view.viewW;
      for (let x = x0; x <= x1; x += step) {
        const p0 = view.toScreen(x, view.worldY0);
        const p1 = view.toScreen(x, view.worldY0 + view.viewH);
        ctx.beginPath();
        ctx.moveTo(p0.px, p0.py);
        ctx.lineTo(p1.px, p1.py);
        ctx.stroke();
      }

      const y0 = Math.floor(view.worldY0 / step) * step;
      const y1 = view.worldY0 + view.viewH;
      for (let y = y0; y <= y1; y += step) {
        const p0 = view.toScreen(view.worldX0, y);
        const p1 = view.toScreen(view.worldX0 + view.viewW, y);
        ctx.beginPath();
        ctx.moveTo(p0.px, p0.py);
        ctx.lineTo(p1.px, p1.py);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawGoal(view, sim) {
      const xL = sim.xg_m - sim.wg_m/2;
      const xR = sim.xg_m + sim.wg_m/2;
      const yRim = sim.yg_m;
      const yBot = sim.yg_m - sim.depth_m;

      const pTL = view.toScreen(xL, yRim);
      const pTR = view.toScreen(xR, yRim);
      const pBL = view.toScreen(xL, yBot);
      const pBR = view.toScreen(xR, yBot);

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 3;

      // bucket outline
      ctx.beginPath();
      ctx.moveTo(pTL.px, pTL.py);
      ctx.lineTo(pBL.px, pBL.py);
      ctx.lineTo(pBR.px, pBR.py);
      ctx.lineTo(pTR.px, pTR.py);
      ctx.stroke();

      // rim highlight
      ctx.globalAlpha = 0.55;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pTL.px, pTL.py);
      ctx.lineTo(pTR.px, pTR.py);
      ctx.stroke();

      // label
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Goal (top opening)", pTR.px + 8, pTR.py + 4);

      ctx.restore();
    }

    function drawTrajectory(view, sim) {
      const tGround = timeOfFlightToGround(sim);
      const tMax = isFinite(tGround) ? tGround : 6;

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 2;

      const N = 260;
      ctx.beginPath();
      for (let i = 0; i <= N; i++) {
        const t = (tMax * i) / N;
        const s = stateAtTime(sim, t);
        if (s.y < -inToM(48)) break;
        const q = view.toScreen(s.x, s.y);
        if (i === 0) ctx.moveTo(q.px, q.py);
        else ctx.lineTo(q.px, q.py);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawTimeTicks(view, sim) {
      const tGround = timeOfFlightToGround(sim);
      const tMax = isFinite(tGround) ? Math.min(tGround, 10) : 10;
      const tickEvery = chooseNiceStep(tMax / 8);

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace";

      for (let t = 0; t <= tMax + 1e-6; t += tickEvery) {
        const s = stateAtTime(sim, t);
        if (s.y < 0) continue;
        const q = view.toScreen(s.x, s.y);
        ctx.beginPath();
        ctx.arc(q.px, q.py, 2.6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillText(t.toFixed(2) + "s", q.px + 6, q.py - 6);
      }
      ctx.restore();
    }

    function drawBalls(view, sim, balls, tNow) {
      const radiusPx = view.metersToPixels(sim.r_m);

      ctx.save();
      // Yellow balls
      ctx.fillStyle = "rgba(255, 230, 0, 0.95)";
      ctx.strokeStyle = "rgba(0,0,0,0.25)";
      ctx.lineWidth = 1;

      for (const b of balls) {
        const age = tNow - b.birth;
        if (age < 0) continue;

        const s = stateAtTime(sim, age);
        if (s.y < -inToM(48)) continue;

        const q = view.toScreen(s.x, s.y);

        const alpha = clamp(1.0 - (age / 6.0) * 0.45, 0.18, 1.0);
        ctx.globalAlpha = alpha;

        ctx.beginPath();
        ctx.arc(q.px, q.py, radiusPx, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }

      ctx.restore();
    }

    // ============================
    // Simulation loop
    // ============================
    let tNow = 0;           // sim time (seconds)
    let lastReal = 0;
    let nextSpawn = 0;
    let balls = [];         // {birth}
    let cachedScore = null;

    function recomputeDerived() {
      const ui = readUI();
      const sim = uiToSim(ui);
      cachedScore = scores(sim);
    }

    function resetTime() {
      tNow = 0;
      lastReal = performance.now();
      nextSpawn = 0;
      balls = [];

      // spawn immediately
      balls.push({ birth: 0 });

      const ui = readUI();
      if (ui.rate > 0) nextSpawn = 1 / ui.rate;
      else nextSpawn = Infinity;
    }

    function updateStats() {
      const ui = readUI();
      const sim = uiToSim(ui);

      const th = deg2rad(sim.ang_deg);
      const vx = sim.v0_mps * Math.cos(th);
      const vy0 = sim.v0_mps * Math.sin(th);

      const tGround = timeOfFlightToGround(sim);
      const rangeM = isFinite(tGround) ? vx * tGround : Infinity;

      const tAtGoal = timeToReachX(sim, sim.xg_m);
      const yAtGoalM = isFinite(tAtGoal)
        ? (sim.y0_m + vy0 * tAtGoal - 0.5 * sim.g_mps2 * tAtGoal * tAtGoal)
        : NaN;

      // apex
      let maxH = sim.y0_m;
      if (Math.abs(sim.g_mps2) > 1e-9) {
        const tApex = vy0 / sim.g_mps2;
        if (tApex > 0) {
          const sA = stateAtTime(sim, tApex);
          maxH = Math.max(maxH, sA.y);
        }
      }

      const score = cachedScore && cachedScore.score;
      const scorePill = score
        ? `<span class="pill ok">SCORES</span>`
        : `<span class="pill bad">NO SCORE</span>`;
      const reason = (!score && cachedScore && cachedScore.reason)
        ? ` <span class="pill warn">${cachedScore.reason}</span>`
        : "";

      // Convert a few values back to inches-based display:
      const vx_in = mPerSecToInPerSec(vx);
      const vy0_in = mPerSecToInPerSec(vy0);
      const maxH_in = mToIn(maxH);
      const range_in = mToIn(rangeM);
      const yAtGoal_in = mToIn(yAtGoalM);

      controls.stats.innerHTML = `
        <div>vx = <span class="pill">${fmt(vx_in,1)} in/s</span> • vy₀ = <span class="pill">${fmt(vy0_in,1)} in/s</span></div>
        <div>Max height ≈ <span class="pill">${fmt(maxH_in,1)} in</span> • Time of flight ≈ <span class="pill">${isFinite(tGround) ? fmt(tGround,2) + " s" : "—"}</span></div>
        <div>Range to ground ≈ <span class="pill">${isFinite(range_in) ? fmt(range_in,1) + " in" : "—"}</span></div>
        <div>At goal center x=${fmt(ui.xg,1)} in: y ≈ <span class="pill">${isFinite(yAtGoal_in) ? fmt(yAtGoal_in,1) + " in" : "—"}</span> • t ≈ <span class="pill">${isFinite(tAtGoal) ? fmt(tAtGoal,2) + " s" : "—"}</span></div>
        <div>${scorePill}${reason}</div>
      `;
    }

    function render() {
      const ui = readUI();
      const sim = uiToSim(ui);
      const view = makeView(sim);

      clear();
      drawGrid(view);
      drawGoal(view, sim);

      if (ui.showCurve) drawTrajectory(view, sim);
      if (ui.showTicks) drawTimeTicks(view, sim);

      drawBalls(view, sim, balls, tNow);

      // Launch marker
      const launch = view.toScreen(0, sim.y0_m);
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(launch.px, launch.py, 5, 0, Math.PI*2);
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Launch", launch.px + 10, launch.py + 4);
      ctx.restore();
    }

    function step(realNow) {
      const ui = readUI();

      if (!lastReal) lastReal = realNow;
      const dtReal = (realNow - lastReal) / 1000;
      lastReal = realNow;

      if (!ui.paused) {
        const dtSim = dtReal * ui.speed;
        tNow += dtSim;

        if (ui.rate > 0) {
          const period = 1 / ui.rate;
          while (tNow >= nextSpawn) {
            balls.push({ birth: nextSpawn });
            nextSpawn += period;

            if (balls.length > ui.maxBalls) {
              balls.splice(0, balls.length - ui.maxBalls);
            }
          }
        }
      }

      // cull old balls
      const sim = uiToSim(ui);
      const tGround = timeOfFlightToGround(sim);
      const tCull = (isFinite(tGround) ? tGround : 8) + 2;
      balls = balls.filter(b => (tNow - b.birth) <= tCull);

      render();
      requestAnimationFrame(step);
    }

    // ============================
    // Change handling
    // ============================
    function onAnyChange() {
      syncNumbersFromRanges();
      recomputeDerived();
      updateStats();

      // keep spawn schedule consistent with rate changes
      const ui = readUI();
      if (ui.rate <= 0) {
        nextSpawn = Infinity;
      } else {
        const period = 1 / ui.rate;
        nextSpawn = Math.ceil(tNow / period) * period;
      }
    }

    // Range inputs update number boxes and sim
    const rangeIds = ["y0","ang","v0","g","xg","yg","wg","depth","rate","r","speed","maxBalls"];
    for (const id of rangeIds) {
      controls[id].addEventListener("input", onAnyChange);
      controls[id].addEventListener("change", onAnyChange);
    }

    // Number inputs update ranges and sim
    const pairMap = [
      ["y0","y0_num"],
      ["ang","ang_num"],
      ["v0","v0_num"],
      ["g","g_num"],
      ["xg","xg_num"],
      ["yg","yg_num"],
      ["wg","wg_num"],
      ["depth","depth_num"],
      ["rate","rate_num"],
      ["r","r_num"],
      ["speed","speed_num"],
      ["maxBalls","maxBalls_num"]
    ];

    for (const [rangeId, numId] of pairMap) {
      const r = controls[rangeId];
      const n = controls[numId];

      // When typing, update on change/enter/blur
      const handler = () => {
        setRangeFromNumber(r, n);
        onAnyChange();
      };
      n.addEventListener("change", handler);
      n.addEventListener("blur", handler);
      n.addEventListener("keydown", (e) => {
        if (e.key === "Enter") handler();
      });
    }

    // Checkboxes
    controls.showCurve.addEventListener("change", onAnyChange);
    controls.showTicks.addEventListener("change", onAnyChange);
    controls.autoZoom.addEventListener("change", onAnyChange);
    controls.paused.addEventListener("change", onAnyChange);

    // Buttons
    controls.reset.addEventListener("click", () => resetTime());
    controls.saveLocal.addEventListener("click", () => saveSettingsLocal());

    // Export / import
    controls.exportBtn.addEventListener("click", exportToFile);
    controls.copyBtn.addEventListener("click", copySettingsText);
    controls.applyTextBtn.addEventListener("click", () => applySettingsText(controls.settingsText.value));

    controls.importBtn.addEventListener("click", async () => {
      const f = controls.importFile.files && controls.importFile.files[0];
      if (!f) {
        alert("Choose a .json file first.");
        return;
      }
      await importFromFile(f);
    });

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        controls.paused.checked = !controls.paused.checked;
        onAnyChange();
      }
      if (e.key === "r" || e.key === "R") {
        resetTime();
      }
    });

    // ============================
    // Init
    // ============================
    resizeCanvas();

    // Ensure number fields have min/max-ish context; set initial from local
    const initial = loadSettingsLocal();
    writeUI(initial);

    // Put current settings in the textarea on load (handy for “versions”)
    controls.settingsText.value = JSON.stringify(currentSettingsEnvelope(), null, 2);

    recomputeDerived();
    updateStats();
    resetTime();
    requestAnimationFrame(step);
  </script>
</body>
</html>
